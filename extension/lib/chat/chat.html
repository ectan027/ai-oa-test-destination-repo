<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Interviewer</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      color: var(--vscode-editor-foreground);
      background-color: var(--vscode-editor-background);
    }
    #chat-log {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    #chat-form {
      display: flex;
      padding: 10px;
      background: var(--vscode-editor-inactiveSelectionBackground);
    }
    #chat-input {
      flex: 1;
      padding: 8px;
      font-size: 1rem;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      border-radius: 4px;
    }
    #chat-input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #chat-submit {
      margin-left: 10px;
      padding: 8px 16px;
      font-size: 1rem;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #chat-submit:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #chat-submit:hover:not(:disabled) {
      background-color: var(--vscode-button-hoverBackground);
    }
    .chat-message {
      margin-bottom: 16px;
      border-radius: 8px;
      padding: 10px 16px;
      max-width: 80%;
      word-wrap: break-word;
    }
    .user {
      background-color: var(--vscode-input-background, rgba(255,255,255,0.1));
      align-self: flex-end;
      margin-left: auto;
    }
    .interviewer {
      background-color: var(--vscode-editor-inactiveSelectionBackground, rgba(255,255,255,0.05));
      align-self: flex-start;
      margin-right: auto;
      color: var(--vscode-editor-foreground, #e7e7e7);
    }
    .chat-header {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .chat-content {
      white-space: pre-wrap;
    }
    #interview-controls {
      display: flex;
      justify-content: center;
      padding: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    #start-final-interview {
      padding: 8px 16px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    #start-final-interview:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .system-message {
      text-align: center;
      padding: 8px;
      margin: 8px 0;
      font-style: italic;
      color: var(--vscode-editorWarning-foreground);
    }
    #chat-log {
      display: flex;
      flex-direction: column;
    }
    #timer-container {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 10px 0;
    }
    #timer {
      font-size: 16px;
      font-weight: bold;
      padding: 5px 10px;
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      border-radius: 4px;
      margin-right: 10px;
    }
    .action-button {
      padding: 8px 12px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }
    .action-button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 10px;
      background-color: var(--vscode-editor-background);
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .title {
      font-weight: bold;
      font-size: 14px;
    }
    /* Add a style for expired timer */
    #timer.expired {
      background-color: var(--vscode-errorForeground, red);
      color: white;
    }
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    .message {
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 5px;
      max-width: 80%;
      word-wrap: break-word;
    }
    .user-message {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      margin-left: auto;
    }
    .ai-message {
      background-color: var(--vscode-editor-inactiveSelectionBackground);
      color: var(--vscode-editor-foreground);
    }
    .system-message {
      background-color: transparent;
      color: var(--vscode-descriptionForeground);
      font-style: italic;
      text-align: center;
      max-width: 100%;
      border-top: 1px solid var(--vscode-panel-border);
      border-bottom: 1px solid var(--vscode-panel-border);
      margin: 10px 0;
      padding: 5px 0;
    }
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    #chat-form {
      display: flex;
      padding: 10px;
      border-top: 1px solid var(--vscode-panel-border);
    }
    #chat-input {
      flex: 1;
      padding: 8px;
      border: 1px solid var(--vscode-input-border);
      border-radius: 4px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      resize: none;
    }
    #chat-submit {
      margin-left: 10px;
      padding: 8px 16px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #chat-submit:hover:not(:disabled) {
      background-color: var(--vscode-button-hoverBackground);
    }
    /* Additional styles for the timer info */
    .timer-info {
      padding: 8px 12px;
      background-color: var(--vscode-editorInfo-background, rgba(0,127,255,0.1));
      color: var(--vscode-editorInfo-foreground, #2040a0);
      text-align: center;
      font-size: 12px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    /* Hidden class */
    .hidden {
      display: none !important;
    }
    /* Final interview button container */
    #final-interview-container {
      display: none;
      padding: 12px;
      text-align: center;
      border-top: 1px solid var(--vscode-panel-border);
    }
    
    #final-interview-container.visible {
      display: block;
    }

    #start-final-interview {
      padding: 10px 16px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
    }

    #start-final-interview:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    
    /* Interview phase label */
    .phase-label {
      font-size: 12px;
      font-weight: bold;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      margin-bottom: 10px;
    }
    
    .phase-label.initial {
      background-color: var(--vscode-editorInfo-background, rgba(0,127,255,0.1));
      color: var(--vscode-editorInfo-foreground, #2040a0);
    }
    
    .phase-label.final {
      background-color: var(--vscode-editorWarning-background, rgba(255,127,0,0.1));
      color: var(--vscode-editorWarning-foreground, #a05000);
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div class="header">
      <div class="title">AI Assessment</div>
      <div class="timer-container" id="timer-section">
        <div id="timer">10:00</div>
        <button id="start-interview" class="action-button">Start Interview</button>
      </div>
    </div>
    
    <div class="timer-info" id="timer-info">
      The timer starts automatically. You can start the interview at any time, or it will start automatically when the timer reaches zero.
    </div>
    
    <div class="messages" id="messages"></div>
    
    <div id="final-interview-container">
      <p>The initial interview is complete. When you are ready, submit your work and begin the final interview.</p>
      <button id="start-final-interview">Submit and Start Final Interview</button>
    </div>
    
    <form id="chat-form">
      <textarea id="chat-input" placeholder="Type your message..." rows="3" disabled></textarea>
      <button id="chat-submit" type="submit" disabled>Send</button>
    </form>
  </div>
  
  <script>
    (function() {
      const vscode = acquireVsCodeApi(); // VS Code API for message passing
      const messagesContainer = document.getElementById('messages');
      const chatForm = document.getElementById('chat-form');
      const chatInput = document.getElementById('chat-input');
      const chatSubmit = document.getElementById('chat-submit'); 
      const startInterviewBtn = document.getElementById('start-interview');
      const timerElement = document.getElementById('timer');
      const timerSection = document.getElementById('timer-section');
      const timerInfo = document.getElementById('timer-info');
      const finalInterviewContainer = document.getElementById('final-interview-container');
      const startFinalInterviewBtn = document.getElementById('start-final-interview');

      // Global variables to store chat history, workspace context, and prompts
      let chatHistory = [];
      let workspaceContext = '';
      let initialPrompt = '';
      let finalPrompt = '';
      let assessmentPrompt = '';
      let initialInterviewStarted = false;
      let finalInterviewStarted = false;
      let initialInterviewEnded = false;
      let timerStarted = false;
      let timerEndTime = null;
      let timerInterval = null;
      let instanceId = null;
      let currentInterviewPhase = 'initial'; // 'initial' or 'final'

      // Immediately request environment prompts
      vscode.postMessage({ command: 'getEnvironmentPrompts' });

      // Appends a message to the chat log and record it in chatHistory.
      function appendMessage(role, text, isSystemMessage = false) {
        // Ensure we have a valid container to append to
        if (!messagesContainer) {
          console.error('Error: Message container not found');
          return chatHistory;
        }
        
        const messageElem = document.createElement('div');
        
        if (isSystemMessage) {
          messageElem.className = 'system-message';
          messageElem.textContent = text;
        } else {
          messageElem.className = `message ${role === 'user' ? 'user-message' : 'ai-message'}`;
          
          // Add phase label for non-system messages if in final interview
          if (finalInterviewStarted && !document.querySelector('.phase-label.final')) {
            const phaseLabel = document.createElement('div');
            phaseLabel.className = 'phase-label final';
            phaseLabel.textContent = 'Final Interview';
            messagesContainer.appendChild(phaseLabel);
          } else if (!finalInterviewStarted && !initialInterviewEnded && !document.querySelector('.phase-label.initial') && chatHistory.length === 0) {
            // Add initial phase label for the first message
            const phaseLabel = document.createElement('div');
            phaseLabel.className = 'phase-label initial';
            phaseLabel.textContent = 'Initial Interview';
            messagesContainer.appendChild(phaseLabel);
          }
          
          const contentElem = document.createElement('div');
          contentElem.className = 'message-content';
          contentElem.textContent = text;
          
          messageElem.appendChild(contentElem);
          
          // Record message in history
          const messageObj = { 
            role: role === 'user' ? 'user' : 'assistant', 
            content: text,
            phase: finalInterviewStarted ? 'final' : 'initial'
          };
          chatHistory.push(messageObj);
          console.log(`Added ${role} message to chatHistory. Length now: ${chatHistory.length}`);
        }
        
        messagesContainer.appendChild(messageElem);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        return chatHistory;
      }

      // Start the initial interview
      function startInitialInterview() {
        if (initialInterviewStarted) return;
        initialInterviewStarted = true;
        
        // Show a system message indicating the start of the initial interview
        appendMessage('system', 'Initial Interview Started', true);
        
        // Add a loading message while we wait for the AI's first question
        const loadingMessageId = 'loading-message';
        const loadingMessage = document.createElement('div');
        loadingMessage.id = loadingMessageId;
        loadingMessage.className = 'system-message';
        loadingMessage.textContent = 'Waiting for interviewer to ask the first question...';
        messagesContainer.appendChild(loadingMessage);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Hide the timer and timer info when interview starts
        timerSection.classList.add('hidden');
        timerInfo.classList.add('hidden');
        
        // Disable the input while waiting for first question
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Notify the server that the interview has started
        vscode.postMessage({
          command: 'startInterview',
          instanceId
        });
        
        // Send an automatic first message
        setTimeout(() => {
          // Automatically send the first message from the user
          const initialUserMessage = "I am ready to start the initial interview.";
          
          // Add user message to the UI
          appendMessage('user', initialUserMessage);
          
          // Build complete messages array including system prompts and chat history
          const systemMessages = [];
          
          // Add the specific interview prompt if provided
          if (initialPrompt) {
            systemMessages.push({ role: "system", content: initialPrompt + " Based on the candidate's responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with 'END' as your complete message. Otherwise, ask your next question." });
          } else {
            // Default system message
            systemMessages.push({ role: "system", content: 'You are a technical interviewer assessing a software engineering candidate. They have been provided with a coding project. Interview them about their design decisions and implementation. IMPORTANT: Ask only ONE question at a time, and wait for their response before asking the next question. Keep your questions concise and focused. Based on the candidate\'s responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with \'END\' as your complete message. Otherwise, ask your next question.' });
          }
          
          // Always include workspace content if available
          if (workspaceContext) {
            systemMessages.push({ role: "system", content: "Project workspace content: " + workspaceContext });
          }
          
          // Construct the payload with all messages using the standardized format
          const payload = {
              "messages": [
                ...systemMessages,
                { role: "user", content: initialUserMessage }
              ]
          };
          
          // Send message to extension using the standard message sending channel
          vscode.postMessage({
            command: 'chatMessage',
            payload: payload,
            instanceId
          });
        }, 500); // Short delay to ensure interview started is processed first
      }

      // Retrieve all files in the workspace
      function requestWorkspaceContext() {
        vscode.postMessage({ command: 'getWorkspaceContent' });
      }
      
      // Retrieve all files immediately then every 30 seconds (reduced frequency to be less intrusive)
      requestWorkspaceContext();
      setInterval(requestWorkspaceContext, 30000);

      // Function to check if timer already exists and get status upon initial load
      function checkExistingTimer() {
        if (!instanceId) {
          console.log('Cannot check timer: No instance ID available');
          return;
        }
        
        console.log(`Checking if timer exists for instance ${instanceId}`);
        vscode.postMessage({ command: 'getTimerStatus', instanceId });
      }

      // Function to handle timer status updates from the server
      function handleTimerStatus(data) {
        console.log('Received timer status:', data);
        
        if (data.error) {
          console.error('Timer error:', data.error);
          timerElement.textContent = 'Timer error';
          return;
        }
        
        // Update the global timer end time
        if (data.endTimeMs) {
          timerEndTime = data.endTimeMs;
          console.log(`Timer end time set to: ${new Date(timerEndTime).toISOString()}`);
        }
        
        // Check if interview is already marked as started
        if (data.interviewStarted) {
          console.log('Interview already started according to server');
          initialInterviewStarted = true;
          
          // Hide timer UI
          timerSection.classList.add('hidden');
          timerInfo.classList.add('hidden');
          
          // Enable chat input
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        }
        
        // Set up timer display updates
        updateTimerDisplay();
        
        // Clear any existing interval to prevent duplicates
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        // Start a new interval for timer updates
        timerInterval = setInterval(updateTimerDisplay, 1000);
        
        // Mark timer as started
        timerStarted = true;
      }

      // Update timer display
      function updateTimerDisplay() {
        if (!timerEndTime) {
          console.log('No timer end time available');
          return;
        }
        
        const now = Date.now();
        const timeLeft = Math.max(0, timerEndTime - now);
                
        // Format the time remaining
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        timerElement.textContent = display;
        
        // Check if timer expired
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          timerElement.textContent = '0:00';
          timerElement.classList.add('expired');
          console.log('Timer expired');
          
          // Auto-start interview if timer expires and interview not started
          if (!initialInterviewStarted) {
            startInitialInterview();
          }
        }
      }

      // Function to handle chat history
      function handleChatHistory(history) {
        console.log(`Received chat history with ${history?.length || 0} messages`);
        
        // Don't try to process empty history
        if (!history || !Array.isArray(history) || history.length === 0) {
          console.log('No chat history to display or invalid history format');
          return;
        }
        
        // Debug log entire history for diagnosis
        console.log('Full history object:', JSON.stringify(history));
        
        // Clear any existing messages first
        messagesContainer.innerHTML = '';
        chatHistory = [];
        
        // Add each message to the UI and to chat history
        let messagesAdded = 0;
        history.forEach((message, index) => {
          try {
            // Check for required fields
            if (!message.role || !message.content) {
              console.warn(`Skipping invalid message at index ${index}: missing role or content`);
              return;
            }
            
            // Add to UI
            const role = message.role;
            const content = message.content;
            
            console.log(`Adding message ${index + 1}/${history.length} from history: role=${role}, content=${content.substring(0, 30)}...`);
            
            // Create message element
            const messageElem = document.createElement('div');
            messageElem.className = `message ${role === 'user' ? 'user-message' : 'ai-message'}`;
            
            // Create content element
            const contentElem = document.createElement('div');
            contentElem.className = 'message-content';
            contentElem.textContent = content;
            
            // Add content to message
            messageElem.appendChild(contentElem);
            
            // Add to UI
            messagesContainer.appendChild(messageElem);
            
            // Add to chat history array
            chatHistory.push({
              role: role,
              content: content
            });
            
            messagesAdded++;
          } catch (err) {
            console.error(`Error processing message ${index}:`, err);
          }
        });
        
        console.log(`Successfully restored ${messagesAdded} messages from history`);
        
        // Scroll to the bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // If we have chat history, the interview has started
        if (chatHistory.length > 0) {
          console.log('Chat history found - marking interview as started');
          initialInterviewStarted = true;
          
          // Hide timer UI and enable chat
          timerSection.classList.add('hidden');
          timerInfo.classList.add('hidden');
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        }
      }

      // Handle messages from the extension
      window.addEventListener('message', event => {
        const message = event.data;
        
        console.log(`Received message from extension: ${message.command}`);
        
        // If we get a GPT response
        if (message.command === 'chatResponse') {
          if (message.error) {
            appendMessage('system', `Error: ${message.error}`, true);
          } else {
            const reply = message.reply || 'No reply';
            
            // Check if the reply is "END" to handle interview ending
            if (reply.trim() === 'END') {
              // Display a system message instead of the "END" message
              appendMessage('system', 'The interviewer has concluded the interview. Thank you for your responses!', true);
              console.log('Interview ended by AI with END message');
              
              // Mark the appropriate interview phase as ended
              if (!finalInterviewStarted) {
                initialInterviewEnded = true;
                
                // Show the final interview button and disable chat input
                finalInterviewContainer.classList.add('visible');
                chatInput.disabled = true;
                chatSubmit.disabled = true;
                
                // Save initial interview flag to backend
                vscode.postMessage({
                  command: 'saveInterviewPhase',
                  phase: 'initial',
                  instanceId
                });
              } else {
                // This is the end of the final interview
                appendMessage('system', 'The final interview has concluded. Thank you for your participation!', true);
                chatInput.disabled = true;
                chatSubmit.disabled = true;
                
                // Save final interview flag to backend
                vscode.postMessage({
                  command: 'saveInterviewPhase',
                  phase: 'final',
                  instanceId
                });
              }
            } else {
              // Normal reply
              appendMessage('assistant', reply);
            }
          }
          
          // Enable input after response unless initial interview has ended and final not started
          if (!initialInterviewEnded || finalInterviewStarted) {
            chatInput.disabled = false;
            chatSubmit.disabled = false;
          }
        } 
        // If we get the contents of this workspace
        else if (message.command === 'workspaceContent') { 
          if (message.error) {
            console.error('Error retrieving workspace content:', message.error);
          } else {
            workspaceContext = message.content;
          }
        }
        // If we get the environment prompts
        else if (message.command === 'environmentPrompts') {
          if (message.error) {
            console.error('Error retrieving environment prompts:', message.error);
          }
          
          initialPrompt = message.initialPrompt;
          finalPrompt = message.finalPrompt;
          assessmentPrompt = message.assessmentPrompt;
          
          // Store the instance ID if provided
          if (message.instanceId) {
            instanceId = message.instanceId;
            console.log(`Instance ID set: ${instanceId}`);
          }
        }
        // If we get timer status from server
        else if (message.command === 'timerStatus') {
          handleTimerStatus(message.data);
        }
        // Handle chat message received
        else if (message.command === 'chatMessage') {
          // Remove loading message if it exists
          const loadingMessage = document.getElementById('loading-message');
          if (loadingMessage) {
            loadingMessage.remove();
          }
          
          appendMessage('assistant', message.text);
          
          // Enable input after response
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        }
        // Handle chat history received
        else if (message.command === 'chatHistory') {
          if (message.error) {
            console.error('Error retrieving chat history:', message.error);
          } else if (message.history) {
            console.log(`Received chat history with ${message.history.length} messages. Processing...`);
            handleChatHistory(message.history);
            
            // If there's chat history, the interview must have started
            if (message.interviewStarted || (message.history && message.history.length > 0)) {
              initialInterviewStarted = true;
              
              // Hide timer UI
              timerSection.classList.add('hidden');
              timerInfo.classList.add('hidden');
              
              // Enable chat input
              chatInput.disabled = false;
              chatSubmit.disabled = false;
            }
          } else {
            console.log('Received chatHistory command but no history was included');
          }
        }
        // Handle interview started confirmation
        else if (message.command === 'interviewStarted') {
          console.log('Interview started status confirmed by server');
          initialInterviewStarted = true;
          
          // Hide timer UI
          timerSection.classList.add('hidden');
          timerInfo.classList.add('hidden');
          
          // Enable chat input
          chatInput.disabled = false;
          chatSubmit.disabled = false;
          
          // Update timer status if provided
          if (message.timer) {
            handleTimerStatus(message.timer);
          }
        }
        // Handle final interview started confirmation
        else if (message.command === 'finalInterviewStarted') {
          console.log('Final interview started status confirmed by server');
          finalInterviewStarted = true;
          initialInterviewEnded = true;
          
          // Enable chat input for final interview
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        }
      });

      // Set up form submission
      chatForm.addEventListener('submit', (e) => {
        e.preventDefault();
        
        const messageText = chatInput.value.trim();
        if (!messageText) return;
        
        console.log(`User submitting message: "${messageText}"`);
        
        // Disable input while waiting for response
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Add user message to chat UI and history
        appendMessage('user', messageText);
        
        // Log the state of chatHistory
        console.log(`Chat history after adding message. Length: ${chatHistory.length}`);
        if (chatHistory.length > 0) {
          console.log(`Last message in history: role=${chatHistory[chatHistory.length-1].role}, content=${chatHistory[chatHistory.length-1].content.substring(0, 30)}...`);
        }
        
        // Build complete messages array including system prompts and chat history
        const systemMessages = [];
        
        // Base prompt depending on interview stage
        let basePrompt = '';
        if (initialInterviewStarted && finalInterviewStarted) {
          // Final interview mode
          basePrompt = finalPrompt;
        } else if (initialInterviewStarted) {
          // Initial interview mode
          basePrompt = initialPrompt;
        } else {
          // Default system message
          basePrompt = 'You are a technical interviewer assessing a software engineering candidate. They have been provided with a coding project. Interview them about their design decisions and implementation. IMPORTANT: Ask only ONE question at a time, and wait for their response before asking the next question. Keep your questions concise and focused.';
        }
        
        // Add instruction to end interview when appropriate
        const endingInstructions = " Based on the candidate's responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with 'END' as your complete message. Otherwise, ask your next question.";
        
        // Add the combined prompt
        systemMessages.push({ role: "system", content: basePrompt + endingInstructions });
        
        // Always include workspace content if available
        if (workspaceContext) {
          systemMessages.push({ role: "system", content: "Project workspace content: " + workspaceContext });
        }
        
        // Construct the payload with all messages using the standardized format
        const payload = {
          "payload": {
            "messages": [
              ...systemMessages,
              ...chatHistory
            ]
          }
        };
        
        // Check if user message is in payload
        const userMessages = payload.payload.messages.filter(m => m.role === 'user');
        console.log(`User messages in payload: ${userMessages.length}`);
        if (userMessages.length > 0) {
          const lastUserMsg = userMessages[userMessages.length - 1];
          console.log(`Last user message in payload: ${lastUserMsg.content.substring(0, 30)}...`);
        } else {
          console.warn('No user messages found in payload!');
        }
        
        // Send message to extension
        vscode.postMessage({
          command: 'chatMessage',
          payload: payload,
          instanceId
        });
        
        // Clear input
        chatInput.value = '';
      });
      
      // Start interview button handler
      startInterviewBtn.addEventListener('click', () => {
        console.log('Start interview button clicked');
        startInitialInterview();
      });

      // Start the final interview
      function startFinalInterview() {
        if (finalInterviewStarted) return;
        
        // First, gather the updated workspace content and submit it to the backend
        console.log('Gathering workspace content for submission...');
        
        // Request fresh workspace content - but don't wait for the response
        vscode.postMessage({ command: 'getWorkspaceContent' });
        
        // Set up a one-time listener for the response with workspace content
        window.addEventListener('message', function workspaceContentListener(event) {
          if (event.data.command === 'workspaceContent') {
            // Remove this one-time listener
            window.removeEventListener('message', workspaceContentListener);
            
            const content = event.data.content;
            if (event.data.error) {
              console.error('Error getting workspace content:', event.data.error);
              return;
            }
            
            console.log(`Got workspace content, size: ${content.length} chars`);
            
            // Submit the workspace content to the backend, but don't wait
            vscode.postMessage({
              command: 'submitWorkspaceContent',
              instanceId,
              content
            });
          }
        });
        
        // Proceed with starting the final interview immediately
        // Clear existing chat history for display purposes
        messagesContainer.innerHTML = '';
        chatHistory = [];
        
        // Mark final interview as started
        finalInterviewStarted = true;
        
        // Hide the final interview button container
        finalInterviewContainer.classList.remove('visible');
        
        // Show a system message indicating the start of the final interview
        appendMessage('system', 'Final Interview Started', true);
        
        // Add a loading message while we wait for the AI's first question
        const loadingMessageId = 'loading-message';
        const loadingMessage = document.createElement('div');
        loadingMessage.id = loadingMessageId;
        loadingMessage.className = 'system-message';
        loadingMessage.textContent = 'Waiting for interviewer to ask the first question...';
        messagesContainer.appendChild(loadingMessage);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Disable the input while waiting for first question
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Notify the server that the final interview has started
        vscode.postMessage({
          command: 'startFinalInterview',
          instanceId
        });
        
        // Send an automatic first message
        setTimeout(() => {
          // Automatically send the first message from the user
          const initialUserMessage = "I am ready to start the final interview. I have completed the coding project.";
          
          // Add user message to the UI
          appendMessage('user', initialUserMessage);
          
          // Build complete messages array including system prompts and chat history
          const systemMessages = [];
          
          // Add the specific interview prompt if provided
          if (finalPrompt) {
            systemMessages.push({ role: "system", content: finalPrompt + " Based on the candidate's responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with 'END' as your complete message. Otherwise, ask your next question." });
          } else {
            // Default system message
            systemMessages.push({ role: "system", content: 'You are a technical interviewer assessing a software engineering candidate. They have been provided with a coding project, which they have now completed. IMPORTANT: Ask only ONE question at a time about their implementation, and wait for their response before asking another question. Start by asking them to explain their overall approach. Based on the candidate\'s responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with \'END\' as your complete message. Otherwise, ask your next question.' });
          }
          
          // Always include workspace content if available
          if (workspaceContext) {
            systemMessages.push({ role: "system", content: "Project workspace content: " + workspaceContext });
          }
          
          // Construct the payload with all messages using the standardized format
          const payload = {
              "payload": {
                "messages": [
                  ...systemMessages,
                  { role: "user", content: initialUserMessage, phase: "final" }
                ]
              }
          };
          
          // Send message to extension
          vscode.postMessage({
            command: 'chatMessage',
            payload: payload,
            instanceId,
            phase: 'final'
          });
        }, 500); // Short delay to ensure everything is processed first
      }
      
      // Start final interview button handler
      startFinalInterviewBtn.addEventListener('click', () => {
        console.log('Start final interview button clicked');
        startFinalInterview();
      });
    }());
  </script>
</body>
</html>